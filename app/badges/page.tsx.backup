'use client'

import { useState, useEffect, useCallback } from 'react'
import { supabase, type Badge, type Team, type RfidScan } from '../../lib/supabase'
import { TagIcon, UserIcon, PlusIcon, ClockIcon } from '@heroicons/react/24/outline'

// Debounce utility function
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout
  return (...args: Parameters<T>) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }
}

interface RfidScanWithStation extends RfidScan {
  stations?: {
    name: string
    location: string
  }
}

export default function BadgesPage() {
  const [badges, setBadges] = useState<Badge[]>([])
  const [teams, setTeams] = useState<Team[]>([])
  const [recentScans, setRecentScans] = useState<RfidScanWithStation[]>([])
  const [loading, setLoading] = useState(true)
  const [fetchingBadges, setFetchingBadges] = useState(false)


  useEffect(() => {
    const initializeData = async () => {
      setLoading(true)
      try {
        await Promise.all([
          fetchBadges(),
          fetchTeams(),
          fetchRecentScans()
        ])
      } finally {
        setLoading(false)
      }
    }
    
    initializeData()
  }, [])



  const fetchBadges = async () => {
    // If already fetching, don't start another fetch
    if (fetchingBadges) {
      console.log('Already fetching badges, skipping duplicate request')
      return
    }
    
    try {
      console.log('Fetching badges from database...')
      setFetchingBadges(true)
      
      // First clear the current badges to prevent duplication
      setBadges([])
      
      // Now fetch from database
      const { data, error } = await supabase
        .from('badges')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) throw error
      
      // Group badges by rfid_uid and take only the first occurrence
      const uniqueMap = new Map();
      if (data) {
        data.forEach(badge => {
          if (!uniqueMap.has(badge.rfid_uid)) {
            uniqueMap.set(badge.rfid_uid, badge);
          }
        });
      }
      
      const uniqueBadges = Array.from(uniqueMap.values());
      console.log('Setting badges state:', uniqueBadges.length, 'unique badges')
      setBadges(uniqueBadges)
    } catch (error) {
      console.error('Error fetching badges:', error)
    } finally {
      setFetchingBadges(false)
    }
  }

  const fetchTeams = async () => {
    try {
      const { data, error } = await supabase
        .from('teams')
        .select('*')
        .order('name', { ascending: true })

      if (error) throw error
      setTeams(data || [])
    } catch (error) {
      console.error('Error fetching teams:', error)
    }
  }

  const fetchRecentScans = async () => {
    try {
      const { data, error } = await supabase
        .from('rfid_scans')
        .select('*')
        .order('scanned_at', { ascending: false })
        .limit(20)

      if (error) throw error
      console.log('Fetched scans:', data) // Debug log
      setRecentScans(data || [])
      
      // Auto-create badges for new UIDs
      await createBadgesForNewUIDs(data || [])
    } catch (error) {
      console.error('Error fetching recent scans:', error)
    } finally {
      setLoading(false)
    }
  }

  const createBadgesForNewUIDs = async (scans: RfidScan[]) => {
    const uniqueUIDs = Array.from(new Set(scans.map(scan => scan.uid)))
    const existingBadges = badges.map(badge => badge.rfid_uid)
    const newUIDs = uniqueUIDs.filter(uid => !existingBadges.includes(uid))

    for (const uid of newUIDs) {
      try {
        // Check if badge already exists in database (in case of race conditions)
        const { data: existingBadge } = await supabase
          .from('badges')
          .select('*')
          .eq('rfid_uid', uid)
          .single()

        if (existingBadge) {
          console.log('Badge already exists for UID:', uid)
          // Add to local state if not already there
          if (!badges.find(b => b.rfid_uid === uid)) {
            setBadges(prev => [existingBadge, ...prev])
          }
          continue
        }

        // Create new badge
        const { data, error } = await supabase
          .from('badges')
          .insert([{ rfid_uid: uid, player_name: null, team_id: null }])
          .select()
          .single()

        if (error) {
          if (error.code === '23505') { // Duplicate key error
            console.log('Badge already exists (race condition) for UID:', uid)
            continue
          }
          throw error
        }

        setBadges(prev => [data, ...prev])
        console.log('Created new badge for UID:', uid)
      } catch (error) {
        console.error('Error creating badge for UID:', uid, error)
      }
    }
  }

  // Set up real-time subscription for RFID scans
  useEffect(() => {
    console.log('Setting up real-time subscription for RFID scans')
    const subscription = supabase
      .channel('rfid_scans_channel')
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'rfid_scans'
        },
        async (payload) => {
          console.log('ðŸŽ¯ Real-time RFID scan received:', payload.new)
          const newScan = payload.new as RfidScanWithStation
          setRecentScans(prev => {
            // Check if scan is already in the list to avoid duplicates
            const exists = prev.some(scan => scan.id === newScan.id)
            if (exists) {
              return prev
            }
            return [newScan, ...prev.slice(0, 19)]
          })
          
          // Auto-create badge if it doesn't exist
          const uid = newScan.uid
          
          // Don't process if we're currently fetching badges to avoid race conditions
          if (fetchingBadges) {
            console.log('Currently fetching badges, skipping auto-create to avoid race condition')
            return
          }
          
          // Check current badges state and database for existing badge
          try {
            // First check if badge exists in current state
            const existsInState = badges.some(badge => badge.rfid_uid === uid)
            
            if (existsInState) {
              console.log('Badge already exists in local state for UID:', uid)
              return
            }
            
            // Then check database
            const { data: existingBadge } = await supabase
              .from('badges')
              .select('*')
              .eq('rfid_uid', uid)
              .single()

            if (!existingBadge) {
              console.log('Creating new badge for UID:', uid)
              const { data: newBadge, error } = await supabase
                .from('badges')
                .insert([{ rfid_uid: uid, player_name: null, team_id: null }])
                .select()
                .single()

              if (!error && newBadge) {
                setBadges(prev => {
                  // Final check before adding to state
                  const exists = prev.some(b => b.rfid_uid === newBadge.rfid_uid)
                  if (exists) {
                    console.log('Badge already exists in state, skipping add')
                    return prev
                  }
                  return [newBadge, ...prev]
                })
                console.log('Created new badge:', newBadge)
              }
            } else {
              console.log('Badge already exists in database for UID:', uid)
              // Make sure the existing badge is in our state
              setBadges(prev => {
                const exists = prev.some(b => b.rfid_uid === uid)
                if (!exists) {
                  console.log('Adding existing badge to state:', existingBadge)
                  return [existingBadge, ...prev]
                }
                return prev
              })
            }
          } catch (error) {
            console.error('Error handling new scan:', error)
            // On error, refresh badges from database to ensure consistency
            // but don't do it if we're already fetching
            if (!fetchingBadges) {
              fetchBadges()
            }
          }
        }
      )
      .subscribe((status) => {
        console.log('Subscription status:', status)
      })

    return () => {
      console.log('Unsubscribing from real-time channel')
      subscription.unsubscribe()
    }
  }, [badges, fetchingBadges]) // Add dependencies to avoid stale closures

  const updateBadgePlayerName = async (badgeId: string, playerName: string) => {
    try {
      // Update local state immediately for responsive UI
      setBadges(prev => prev.map(badge => 
        badge.id === badgeId 
          ? { ...badge, player_name: playerName }
          : badge
      ))

      // Update database
      const { error } = await supabase
        .from('badges')
        .update({ player_name: playerName })
        .eq('id', badgeId)

      if (error) throw error
    } catch (error) {
      console.error('Error updating badge player name:', error)
      // Revert local state on error
      setBadges(prev => prev.map(badge => 
        badge.id === badgeId 
          ? { ...badge, player_name: badge.player_name }
          : badge
      ))
    }
  }

  const assignBadgeToTeam = async (badgeId: string, teamId: string | null) => {
    try {
      const { error } = await supabase
        .from('badges')
        .update({ team_id: teamId })
        .eq('id', badgeId)

      if (error) throw error
      setBadges(prev => prev.map(badge => 
        badge.id === badgeId ? { ...badge, team_id: teamId } : badge
      ))
    } catch (error) {
      console.error('Error assigning badge to team:', error)
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-lg">Loading badges...</div>
      </div>
    )
  }

  const unassignedBadges = badges.filter(badge => !badge.team_id)
  const assignedBadges = badges.filter(badge => badge.team_id)

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <div className="max-w-6xl mx-auto">
        <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-gray-900">Badge Management</h1>
            <button
              onClick={async () => {
                console.log('Refreshing all data...')
                setLoading(true)
                try {
                  // Clear states first
                  setBadges([])
                  setRecentScans([])
                  
                  // Then fetch fresh data
                  await Promise.all([
                    fetchBadges(),
                    fetchRecentScans()
                  ])
                  console.log('Data refresh complete')
                } finally {
                  setLoading(false)
                }
              }}
              disabled={loading || fetchingBadges}
              className={`px-3 py-1 text-sm ${loading || fetchingBadges ? 'bg-gray-400' : 'bg-blue-500 hover:bg-blue-600'} text-white rounded`}
            >
              {loading || fetchingBadges ? 'Refreshing...' : 'Refresh Data'}
            </button>
          </div>

          {/* Recent RFID Scans */}
          <div className="mb-8">
            <h2 className="text-lg font-semibold text-gray-900 mb-4">
              Recent RFID Scans ({recentScans.length})
            </h2>
            {recentScans.length === 0 ? (
              <div className="bg-gray-50 rounded-lg p-4 text-center text-gray-600">
                No recent scans. Scan an RFID badge at any station to see it appear here.
              </div>
            ) : (
              <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                <div className="space-y-2 max-h-60 overflow-y-auto">
                  {recentScans.map((scan, index) => (
                    <div key={`${scan.id}-${index}`} className="flex items-center justify-between bg-white p-3 rounded border">
                      <div className="flex items-center gap-3">
                        <TagIcon className="h-5 w-5 text-green-600" />
                        <div>
                          <div className="font-mono text-sm font-semibold">{scan.uid}</div>
                          <div className="text-xs text-gray-600">
                            Station {scan.station_id === '04bc0dd5-a929-40f7-85d4-db99555b21db' ? '1' : scan.station_id === 'e8a06b61-7a9e-4252-8606-cd6ebcc9f396' ? '3' : 'Unknown'} â€¢ {new Date(scan.scanned_at).toLocaleTimeString()}
                          </div>
                        </div>
                      </div>
                      <div className="text-xs text-gray-500">
                        <ClockIcon className="h-4 w-4 inline mr-1" />
                        {Math.floor((Date.now() - new Date(scan.scanned_at).getTime()) / 1000)}s ago
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Unassigned Badges */}
          <div className="mb-8">
            <h2 className="text-lg font-semibold text-gray-900 mb-4">
              Unassigned Badges ({unassignedBadges.length})
            </h2>
            {unassignedBadges.length === 0 ? (
              <div className="bg-gray-50 rounded-lg p-4 text-center text-gray-600">
                All badges are assigned to teams.
              </div>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {unassignedBadges.map((badge) => (
                  <div key={badge.id} className="bg-white border border-gray-200 rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-3">
                      <TagIcon className="h-5 w-5 text-gray-400" />
                      <span className="font-mono text-sm font-semibold">{badge.rfid_uid}</span>
                    </div>
                    
                    <div className="space-y-3">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Player Name
                        </label>
                        <input
                          type="text"
                          value={badge.player_name || ''}
                          onChange={(e) => updateBadgePlayerName(badge.id, e.target.value)}
                          placeholder="Enter player name"
                          className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Assign to Team
                        </label>
                        <select
                          value={badge.team_id || ''}
                          onChange={(e) => assignBadgeToTeam(badge.id, e.target.value || null)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
                        >
                          <option value="">Select team...</option>
                          {teams.map((team) => (
                            <option key={team.id} value={team.id}>
                              {team.name}
                            </option>
                          ))}
                        </select>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Assigned Badges by Team */}
          <div>
            <h2 className="text-lg font-semibold text-gray-900 mb-4">
              Assigned Badges ({assignedBadges.length})
            </h2>
            {teams.map((team) => {
              const teamBadges = assignedBadges.filter(badge => badge.team_id === team.id)
              if (teamBadges.length === 0) return null

              return (
                <div key={team.id} className="mb-6">
                  <div className="flex items-center gap-2 mb-3">
                    <div 
                      className="w-4 h-4 rounded-full"
                      style={{ backgroundColor: team.color }}
                    />
                    <h3 className="font-semibold text-gray-900">{team.name} ({teamBadges.length} badges)</h3>
                  </div>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    {teamBadges.map((badge) => (
                      <div 
                        key={badge.id} 
                        className="border-2 rounded-lg p-4"
                        style={{ 
                          borderColor: team.color + '40',
                          backgroundColor: team.color + '10'
                        }}
                      >
                        <div className="flex items-center gap-2 mb-2">
                          <UserIcon className="h-5 w-5 text-gray-600" />
                          <span className="font-semibold">
                            {badge.player_name || 'Unnamed Player'}
                          </span>
                        </div>
                        
                        <div className="flex items-center gap-2 mb-3">
                          <TagIcon className="h-4 w-4 text-gray-400" />
                          <span className="font-mono text-sm">{badge.rfid_uid}</span>
                        </div>
                        
                        <div className="space-y-2">
                          <input
                            type="text"
                            value={badge.player_name || ''}
                            onChange={(e) => updateBadgePlayerName(badge.id, e.target.value)}
                            placeholder="Enter player name"
                            className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
                          />
                          
                          <button
                            onClick={() => assignBadgeToTeam(badge.id, null)}
                            className="w-full px-3 py-2 text-sm text-red-600 border border-red-300 rounded-md hover:bg-red-50"
                          >
                            Remove from Team
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )
            })}
            
            {assignedBadges.length === 0 && (
              <div className="bg-gray-50 rounded-lg p-4 text-center text-gray-600">
                No badges assigned to teams yet.
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
